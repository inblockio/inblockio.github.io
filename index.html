<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inblock - Securing Digital Sovereignty</title>
    <link rel="stylesheet" href="./public/css/styles.css">
    <link rel="icon" type="image/x-icon" href="./public/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="./public/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./public/favicon-16x16.png">
</head>
<body>
    <!-- Header -->
    <header>
        <canvas id="header-canvas"></canvas>
        <div class="header-content">
            <img src="./public/logo/inblockio_birdstyle_writing_on_dark.png" alt="inblock.io logo">
            <h1>Building Trust Infrastructure for Sovereign Data Ownership</h1>
            <p>Enable digital sovereignty with open trust infrastructure for secure data asset governance.</p>
        </div>
    </header>

    <!-- Services Section -->
    <section id="services">
        <div class="section-inner">
            <h2>What We Do</h2>
            <p>We build secure trust systems that give organizations full control over their own data. Our solutions provide reliable infrastructure without depending on external platforms.</p>
            <ul>
                <li><strong>Sovereign Data Governance Consulting</strong> - We offer practical strategies to protect privacy, adopt open-source tools, and build lasting digital trust.</li>
                <li><strong>Digital Trust Solutions</strong> - We provide decentralized notarization and contracting that runs entirely on your premises. This gives you a secure, verifiable alternative to common e-signature solutions, with no third-party involvement.</li>
                <li><strong>Aqua Protocol Integration</strong> - We help you integrate verifiable data chains directly into your existing systems, enabling resilient and independent innovation.</li>
            </ul>
            <p>For a client in a highly regulated industry, we set up confidential contract notarization on their own site. The solution kept everything private while delivering strong, verifiable proof for any potential disputes. All of this runs on Aqua Protocol.</p>
        </div>
    </section>

    <!-- Projects Section -->
    <section id="projects">
        <div class="section-inner">
            <h2>Our Work</h2>
            <div class="projects-grid">
                <div class="project-card">
                    <h3><a href="https://aqua-protocol.org" target="_blank">Aqua-Protocol</a></h3>
                    <p>Building the institutional trust layer of the future.</p>
                    <a href="https://aqua-protocol.org" target="_blank" class="project-link">aqua-protocol.org &rarr;</a>
                </div>
                <div class="project-card">
                    <h3>Our Products</h3>
                    <div class="product-list">
                        <div class="product-item">
                            <h4><a href="https://github.com/inblockio/aqua-js-sdk" target="_blank">Aqua-SDK</a></h4>
                            <p>Developer tools for Aqua-Protocol Version 3.2.</p>
                        </div>
                        <div class="product-item">
                            <h4><a href="https://aquafier.inblock.io" target="_blank">AquaFire Application</a></h4>
                            <p>An Aqua-Protocol Version 3.2 enabled Document Management System, Identity System and Document eSigning Solution.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Team Section -->
    <section id="team">
        <div class="section-inner">
            <h2>Who We Are</h2>
            <div class="team-member">
                <h3>Tim Bansemer</h3>
                <p><strong>CEO & Aqua Project Lead</strong></p>
                <p>Tim Bansemer is an accomplished ICT Systems Engineer with over a decade of expertise in IT infrastructure, security, and distributed networks. Beginning his career as a network engineer in 2010, he specialized in IT security from 2014 to 2016 and delved into distributed ledger technologies from 2017 to 2020. Since 2021, Tim has pioneered the Aqua Protocol as CEO of inblock.io assets GmbH, driving innovations in digital sovereignty, data provenance, and cryptographic proofs for verifiable data accounting.</p>
                <p>His vision centers on democratizing digital trust to enhance privacy and collaboration in complex systems. Tim is renowned for assembling high-performing teams from his trusted professional network, seamlessly integrating technical prowess with a commitment to authentic human connections. He actively contributes thought leadership through his <a href="https://digitalfreedom.substack.com" target="_blank">Substack on digital sovereignty and governance</a> (launched 2024), as well as earlier writings on Medium (2018&ndash;2020) exploring human-centric distributed computation and global consciousness.</p>
                <p>Tim's interests encompass governance, open source software, network institutions, and post-quantum cryptography. He leads projects like the AquaFire App, which integrates file storage, e-signatures, and identity verification, and dgov.earth for distributed governance.</p>
                <p>Connect with Tim: <a href="https://linktr.ee/timbansemer" target="_blank">Linktree</a> | <a href="https://github.com/FantasticoFox" target="_blank">GitHub (FantasticoFox)</a> | <a href="https://x.com/tim_bansemer" target="_blank">X (@tim_bansemer)</a></p>
            </div>
            <div class="team-member">
                <h3>Independent Core Contributors</h3>
                <h4>Publius Dirac (GitHub: <a href="https://github.com/rht" target="_blank">rht</a>)</h4>
                <p>Publius Dirac serves as a core contributor to the Aqua Protocol, joining the project in 2021 with a deep passion for free and open-source software and decentralization. Concurrently, he advances quantum computing at a startup, bringing insights into post-quantum cryptography and security. His work emphasizes research and prototyping, enabling elegant and robust solution designs.</p>
            </div>
        </div>
    </section>

    <!-- Contact Section -->
    <section id="contact">
        <div class="section-inner">
            <h2>Connect With Us</h2>
            <p>Reach out via e-mail to info[at]inblock.io</p>
        </div>
    </section>

    <!-- Posts Section -->
    <section id="posts">
        <div class="section-inner">
            <h2>Latest Updates</h2>
            <div class="posts-list">
                <div class="post-item">
                    <h3><a href="./posts/2026-02-07-china-data-balance-sheet.html">China Recognizes Data as a Balance Sheet Asset</a></h3>
                    <p class="post-date">Feb 7, 2026</p>
                    <p>China now allows companies to formally record high-quality data on their balance sheets. This global trend validates the importance of data governance and aligns directly with what Aqua Protocol enables.</p>
                </div>
                <div class="post-item">
                    <h3><a href="./posts/2025-04-16-defining-data-accounting.html">Defining Data Accounting</a></h3>
                    <p class="post-date">Apr 16, 2025</p>
                    <p>CEO Tim Bansemer explores why data needs the same rigorous accounting standards as finance, and introduces a three-dimensional framework for cryptographic data verification implemented in the Aqua Protocol.</p>
                </div>
                <div class="post-item">
                    <h3><a href="./posts/2024-07-20-aqua-guardian.html">Launching Aqua Guardian</a></h3>
                    <p class="post-date">Jul 20, 2024</p>
                    <p>Introducing Aqua Guardian, an open-source component for secure, permissioned access to Aqua Chains. Developed with TU Ilmenau and nominated for a university prize, it brings decentralized data governance to production.</p>
                </div>
                <div class="post-item">
                    <h3><a href="./posts/2022-01-14-aqua-verify.html">Aqua Offline Verifier</a></h3>
                    <p class="post-date">Jan 14, 2022</p>
                    <p>A web service for verifying aqua.json files offline—privacy-first trust, no extensions needed.</p>
                </div>
            </div>
            <a href="./posts/index.html" class="view-all">View All Updates →</a>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <p>&copy; <script>document.write(new Date().getFullYear())</script> Inblock. <a href="https://github.com/inblockio" target="_blank">GitHub</a> | <a href="./impressum.html">Impressum</a></p>
        <p>Building trust and sovereignty, one solution at a time.</p>
    </footer>

    <!-- Aqua-chain stream: genesis left, extensions right, flowing right-to-left -->
    <script>
    (function() {
        var canvas = document.getElementById('header-canvas');
        if (!canvas) return;
        var ctx = canvas.getContext('2d');
        var header = canvas.parentElement;

        canvas.width = header.offsetWidth;
        canvas.height = header.offsetHeight;
        window.addEventListener('resize', function() {
            canvas.width = header.offsetWidth;
            canvas.height = header.offsetHeight;
        });

        // Node type colors
        var COLORS = {
            genesis:   [220, 40, 40],
            revision:  [239, 84, 1],
            signature: [40, 180, 80],
            witness:   [50, 130, 220]
        };

        var DRIFT = 0.35;          // horizontal speed (px/frame) chains move left
        var SPAWN_INTERVAL = 50;   // frames between spawning new chains
        var MAX_CHAINS = 20;       // max simultaneous chains on screen
        var MAX_NODES = 10;        // max nodes per chain before it stops growing
        var NODE_R = 4;            // node circle radius in px
        var LANE_HEIGHT = 0;       // vertical space per lane (computed on init)
        var BRANCH_TYPES = ['revision', 'signature', 'witness']; // fork node types

        var chains = [];           // active chain objects
        var crossLinks = [];       // links between different chains
        var frameCount = 0;        // animation frame counter
        var lanes = [];            // vertical lanes to prevent overlap

        // Opacity: 0 at center, full at edges
        function posAlpha(x) {
            var cx = canvas.width / 2;
            var half = canvas.width / 2;
            var dist = Math.abs(x - cx);
            var fade = dist / (half * 0.6) - 0.25;
            if (fade < 0) fade = 0;
            if (fade > 1) fade = 1;
            return fade * 0.75;
        }

        function rand(a, b) { return a + Math.random() * (b - a); }
        function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
        function pick(arr) { return arr[randInt(0, arr.length - 1)]; }

        var MAX_PER_LANE = 2;      // max chains sharing one lane
        var MIN_LANE_GAP = 250;    // min horizontal px between chains in same lane

        // Set up vertical lanes so chains don't overlap
        function initLanes() {
            var count = 5;
            LANE_HEIGHT = canvas.height / count;
            lanes = [];
            for (var i = 0; i < count; i++) {
                lanes.push({ y: LANE_HEIGHT * (i + 0.5), occupants: [] });
            }
        }
        initLanes();

        // Get rightmost node X of a chain
        function chainMaxX(c) {
            var mx = -Infinity;
            for (var i = 0; i < c.nodes.length; i++) {
                if (c.nodes[i].x > mx) mx = c.nodes[i].x;
            }
            return mx;
        }

        function getFreeLane() {
            // Collect lanes that have room for another chain
            var free = [];
            for (var i = 0; i < lanes.length; i++) {
                var lane = lanes[i];
                if (lane.occupants.length === 0) {
                    free.push(lane);
                } else if (lane.occupants.length < MAX_PER_LANE) {
                    // Check if existing chains have drifted far enough left
                    var hasRoom = true;
                    for (var j = 0; j < lane.occupants.length; j++) {
                        var rightEdge = chainMaxX(lane.occupants[j]);
                        // New chain spawns at canvas.width + 40, need MIN_LANE_GAP gap
                        if (rightEdge > canvas.width + 40 - MIN_LANE_GAP) {
                            hasRoom = false;
                            break;
                        }
                    }
                    if (hasRoom) free.push(lane);
                }
            }
            if (free.length === 0) return null;
            return pick(free);
        }

        // Build a chain: genesis on left, nodes extend rightward on strict horizontal lines.
        // Forks create a new line shifted up or down; each branch continues on its own line.
        function spawnChain() {
            var lane = getFreeLane();
            if (!lane) return;

            var startX = canvas.width + 40;
            // Offset each chain vertically within the lane for a DAG-like staggered look
            var yOffset = (lane.occupants.length % 2 === 0) ? -LANE_HEIGHT * 0.12 : LANE_HEIGHT * 0.12;
            var centerY = lane.y + yOffset;
            var yBand = LANE_HEIGHT * 0.45;
            var forkStep = yBand / 3;    // vertical offset for each fork (wider spacing between branches)
            var nodeStep = rand(24, 36); // horizontal spacing between nodes
            var chain = { nodes: [], edges: [], lane: lane, branches: [] };

            // Genesis node on the main line
            var genesis = { x: startX, y: centerY, type: 'genesis', lineY: centerY };
            chain.nodes.push(genesis);

            // A branch tracks: current tip node, its fixed Y line
            var mainBranch = { tip: genesis, lineY: centerY };
            chain.branches.push(mainBranch);

            // Build initial tree: extend branches and occasionally fork
            var steps = randInt(2, 4);
            for (var i = 0; i < steps; i++) {
                if (chain.nodes.length >= MAX_NODES) break;
                // Extend every active branch by one node
                var branchCount = chain.branches.length;
                for (var b = 0; b < branchCount; b++) {
                    if (chain.nodes.length >= MAX_NODES) break;
                    var br = chain.branches[b];
                    var type = pick(BRANCH_TYPES);
                    var child = {
                        x: br.tip.x + nodeStep,
                        y: br.lineY,
                        type: type,
                        lineY: br.lineY
                    };
                    chain.nodes.push(child);
                    chain.edges.push({ from: br.tip, to: child });
                    br.tip = child;
                }

                // Occasionally fork from a random branch (max 4 branches)
                if (chain.nodes.length < MAX_NODES && Math.random() < 0.3 && chain.branches.length < 4) {
                    var srcBranch = pick(chain.branches);
                    var dir = (Math.random() < 0.5) ? -1 : 1;
                    var newLineY = srcBranch.lineY + dir * forkStep;
                    // Clamp to lane
                    if (newLineY < centerY - yBand) newLineY = centerY - yBand;
                    if (newLineY > centerY + yBand) newLineY = centerY + yBand;
                    // Avoid duplicate Y lines
                    var taken = false;
                    for (var b2 = 0; b2 < chain.branches.length; b2++) {
                        if (Math.abs(chain.branches[b2].lineY - newLineY) < forkStep * 0.5) { taken = true; break; }
                    }
                    if (!taken) {
                        var forkType = pick(BRANCH_TYPES);
                        var forkNode = {
                            x: srcBranch.tip.x + nodeStep,
                            y: newLineY,
                            type: forkType,
                            lineY: newLineY
                        };
                        chain.nodes.push(forkNode);
                        chain.edges.push({ from: srcBranch.tip, to: forkNode });
                        chain.branches.push({ tip: forkNode, lineY: newLineY });
                    }
                }
            }

            lane.occupants.push(chain);
            chains.push(chain);
            addCrossLinks(chain);
        }

        // Pick a target node in another chain: prefer nearby chains + genesis nodes
        function pickTargetNode(sourceNode, otherChain) {
            // Weight each node: genesis gets 5x, closer Y distance gets higher weight
            var weights = [];
            var totalWeight = 0;
            for (var i = 0; i < otherChain.nodes.length; i++) {
                var n = otherChain.nodes[i];
                var yDist = Math.abs(n.y - sourceNode.y);
                var proximity = 1 / (1 + yDist / 40); // closer = higher
                var w = proximity * (n.type === 'genesis' ? 5 : 1);
                weights.push(w);
                totalWeight += w;
            }
            var r = Math.random() * totalWeight;
            var acc = 0;
            for (var i = 0; i < weights.length; i++) {
                acc += weights[i];
                if (r <= acc) return otherChain.nodes[i];
            }
            return otherChain.nodes[otherChain.nodes.length - 1];
        }

        // Average X position of a chain's nodes
        function chainAvgX(c) {
            if (c.nodes.length === 0) return 0;
            var sum = 0;
            for (var i = 0; i < c.nodes.length; i++) sum += c.nodes[i].x;
            return sum / c.nodes.length;
        }

        var MAX_LINKS_PER_PAIR = 2;  // max cross-links between any two chains
        var FLASH_DURATION = 30;     // frames a new cross-link stays highlighted

        // Count existing cross-links between two chains
        function countLinksBetween(a, b) {
            var count = 0;
            for (var i = 0; i < crossLinks.length; i++) {
                var l = crossLinks[i];
                var fromInA = a.nodes.indexOf(l.from) !== -1;
                var toInB = b.nodes.indexOf(l.to) !== -1;
                var fromInB = b.nodes.indexOf(l.from) !== -1;
                var toInA = a.nodes.indexOf(l.to) !== -1;
                if ((fromInA && toInB) || (fromInB && toInA)) count++;
            }
            return count;
        }

        // Create cross-links: prefer nearby chains, strongly favor linking rightward
        function addCrossLinks(chain) {
            var chainX = chainAvgX(chain);
            // Sort other chains by lane distance (nearest first)
            var others = [];
            for (var i = 0; i < chains.length - 1; i++) {
                var dist = Math.abs(chains[i].lane.y - chain.lane.y);
                others.push({ chain: chains[i], dist: dist });
            }
            others.sort(function(a, b) { return a.dist - b.dist; });

            for (var i = 0; i < others.length; i++) {
                var other = others[i].chain;
                if (other.nodes.length === 0) continue;
                // Allow up to MAX_LINKS_PER_PAIR between any two chains
                if (countLinksBetween(chain, other) >= MAX_LINKS_PER_PAIR) continue;
                // Higher chance for nearby chains: 90% for nearest, drops with distance
                var chance = 0.9 / (1 + i * 0.5);
                // Strongly favor linking to chains on the right (left-to-right flow)
                var otherX = chainAvgX(other);
                if (otherX > chainX) {
                    chance *= 3;   // 3x boost for rightward links
                } else {
                    chance *= 0.15; // heavily reduce leftward links
                }
                if (Math.random() < chance) {
                    var fromNode = pick(chain.nodes);
                    var toNode = pickTargetNode(fromNode, other);
                    crossLinks.push({ from: fromNode, to: toNode, birth: frameCount });
                }
            }
        }

        // Grow an existing chain: extend a random branch tip on its fixed line
        function growChain(chain) {
            if (chain.nodes.length >= MAX_NODES || !chain.branches || chain.branches.length === 0) return;
            var br = pick(chain.branches);
            // Increasing chance to finish with witness as chain nears max length
            var remaining = MAX_NODES - chain.nodes.length;
            var witnessChance = (remaining <= 1) ? 1.0 : (remaining <= 3) ? 0.6 : 0.15;
            var type = (Math.random() < witnessChance) ? 'witness' : pick(BRANCH_TYPES);
            var child = {
                x: br.tip.x + rand(24, 36),
                y: br.lineY,
                type: type,
                lineY: br.lineY
            };
            chain.nodes.push(child);
            chain.edges.push({ from: br.tip, to: child });
            br.tip = child;

            // Often add a cross-link when growing: prefer nearby chains to the right
            if (Math.random() < 0.55 && chains.length > 1) {
                var myX = chainAvgX(chain);
                // Find best other chain, preferring rightward and nearby
                var bestChain = null, bestScore = -Infinity;
                for (var k = 0; k < chains.length; k++) {
                    if (chains[k] === chain) continue;
                    if (chains[k].nodes.length === 0) continue;
                    if (countLinksBetween(chain, chains[k]) >= MAX_LINKS_PER_PAIR) continue;
                    var d = Math.abs(chains[k].lane.y - chain.lane.y);
                    var proximity = 1 / (1 + d / 40);
                    // Boost chains to the right, penalize chains to the left
                    var dirBonus = (chainAvgX(chains[k]) > myX) ? 3 : 0.15;
                    var score = proximity * dirBonus;
                    if (score > bestScore) { bestScore = score; bestChain = chains[k]; }
                }
                if (bestChain) {
                    crossLinks.push({ from: child, to: pickTargetNode(child, bestChain), birth: frameCount });
                }
            }
        }

        function drawNode(n) {
            var a = posAlpha(n.x);
            if (a < 0.01) return;
            var c = COLORS[n.type];
            ctx.fillStyle = 'rgba(' + c[0] + ',' + c[1] + ',' + c[2] + ',' + a + ')';
            ctx.beginPath();
            ctx.arc(n.x, n.y, NODE_R, 0, Math.PI * 2);
            ctx.fill();
            if (n.type === 'genesis' && a > 0.15) {
                ctx.fillStyle = 'rgba(' + c[0] + ',' + c[1] + ',' + c[2] + ',' + (a * 0.15) + ')';
                ctx.beginPath();
                ctx.arc(n.x, n.y, NODE_R * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawEdge(from, to) {
            var a = Math.min(posAlpha(from.x), posAlpha(to.x));
            if (a < 0.01) return;
            ctx.strokeStyle = 'rgba(100,160,180,' + (a * 0.6) + ')';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
        }

        function drawCrossLink(link) {
            var a = Math.min(posAlpha(link.from.x), posAlpha(link.to.x));
            if (a < 0.01) return;
            // Flash effect for newly spawned links
            var age = frameCount - (link.birth || 0);
            var flash = (age < FLASH_DURATION) ? 1 - (age / FLASH_DURATION) : 0;
            if (flash > 0) {
                // Bright glow layer
                var glowAlpha = a * flash * 0.8;
                ctx.strokeStyle = 'rgba(255,255,255,' + glowAlpha + ')';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(link.from.x, link.from.y);
                ctx.lineTo(link.to.x, link.to.y);
                ctx.stroke();
            }
            // Normal dashed line (slightly brighter during flash)
            var baseAlpha = a * (0.35 + flash * 0.4);
            ctx.strokeStyle = 'rgba(150,150,200,' + baseAlpha + ')';
            ctx.lineWidth = 0.7 + flash * 1.3;
            ctx.setLineDash([4, 5]);
            ctx.beginPath();
            ctx.moveTo(link.from.x, link.from.y);
            ctx.lineTo(link.to.x, link.to.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            frameCount++;

            // Spawn new chains
            if (frameCount % SPAWN_INTERVAL === 0 && chains.length < MAX_CHAINS) {
                spawnChain();
            }

            // Grow existing chains
            if (frameCount % 70 === 35 && chains.length > 0) {
                growChain(pick(chains));
            }

            // Drift all nodes left
            for (var i = 0; i < chains.length; i++) {
                for (var j = 0; j < chains[i].nodes.length; j++) {
                    chains[i].nodes[j].x -= DRIFT;
                }
            }

            // Remove chains that exited left; free their lane
            chains = chains.filter(function(chain) {
                var maxX = -Infinity;
                for (var j = 0; j < chain.nodes.length; j++) {
                    if (chain.nodes[j].x > maxX) maxX = chain.nodes[j].x;
                }
                if (maxX < -80) {
                    var idx = chain.lane.occupants.indexOf(chain);
                    if (idx !== -1) chain.lane.occupants.splice(idx, 1);
                    return false;
                }
                return true;
            });

            // Clean up stale cross-links
            crossLinks = crossLinks.filter(function(link) {
                return link.from.x > -80 && link.to.x > -80;
            });

            // Draw cross-links (behind)
            for (var i = 0; i < crossLinks.length; i++) {
                drawCrossLink(crossLinks[i]);
            }

            // Draw chain edges then nodes
            for (var i = 0; i < chains.length; i++) {
                var chain = chains[i];
                for (var j = 0; j < chain.edges.length; j++) {
                    drawEdge(chain.edges[j].from, chain.edges[j].to);
                }
                for (var j = 0; j < chain.nodes.length; j++) {
                    drawNode(chain.nodes[j]);
                }
            }

            requestAnimationFrame(animate);
        }

        // Seed initial chains spread across the screen
        initLanes();
        var seedCount = Math.min(12, lanes.length);
        for (var i = 0; i < seedCount; i++) {
            spawnChain();
            var chain = chains[chains.length - 1];
            var shiftX = (seedCount - i) * (canvas.width / (seedCount + 1));
            for (var j = 0; j < chain.nodes.length; j++) {
                chain.nodes[j].x -= shiftX;
            }
        }

        animate();
    })();
    </script>
</body>
</html>
